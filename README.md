# Storage Microservice Design

## 1. Requirements

### Functional Requirements
- **File Storage**: Store files of any extension, Only authorized owners can upload.
- **Files list Retrieval**: Provide list of uploaded files, It should be authorized only by file owner.
- **File Downloading**: Provide download link, It should be authorized only by file owner.
- **Metadata Management**: Extract Meta-data from uploaded file and save it in database.
- **Access Control**: Only authorized users can store and retrieve files.
- **Scalability**: The service should be able to handle a large number of files.
- **Fault Tolerance**: The service should be resilient to failures and ensure data integrity.

### Non-functional Requirements
- **Performance**: The service should provide low-latency storage and retrieval of files.
- **Security**: Files should be stored securely, with encryption at rest and in transit.
- **Reliability**: The service should ensure high availability, with minimal downtime.
- **Compliance**: The service should comply with relevant data protection and privacy regulations.

## 2. Design

### High-Level Design

#### Components
- **Authentication Module**: Authenticates users.
- **File Metadata Module**: Extracts meta-data (filename, Content type, Size and File Path on storage medium).
- **File Storage and Retrieval Module**: Store and Retrieve files from storage medium, it should also encrypt files before storing and decrypt files before downloading.
- **Relational DB**: Saves information about users and files meta-data.
- **Local File Storage**: Saves information about users and files meta-data.


#### High-Level Architecture
![High-Level Architecture](Documentation/Images/HighLevel.png)

### Low-Level Design

#### REST API Service
The Service will be Asp.net core web API with .Net 8 framework, authentication will be done by JWT bearer token, it should be retrieved by authentication request and passed in consequent requests HTTP headers.
C# will be the programming language.

- **Endpoints**:
  - `POST /api/users/authenticate`: Authenticates a user. Request and response content type is "application/json", response will return bearer authentication token.
  - `POST /api/users/register`: Registers a user. Request content type is "application/json". username and password are minimal information.
  - `POST /api/file/upload`: Uploads a file, Request content type is "multipart/form-data".
  - `PUT /api/file/Replace/{FileId}`: Replaces a file related with fileId parameter by file in request, Request content type is "multipart/form-data".
  - `GET /api/file/download/{FileId}`: Downloads a file related with fileId parameter.
  - `GET /api/file/myfiles`: Return list of files uploaded by autherntication user.
  - `DELETE /api/file/delete/{FileId}`: Deletes a file related with fileId parameter.
    
- **File Handling**:
  - Files are encrypted and stored in service's server local storage backend, should be decrypted before downloading.
  - Metadata is stored in a database.
  - Files are associated with a unique ID.

- **Database Handling**:
  - Use Microsoft Entity-Framework core to develop Entity classes and use DB migration to create SQL server database tables.
  - Main Entity classes:
    - `User`: User Identity Entity.
    - `FileMetaData`:File meta-data Entity.

- **Request and Response Model classes**: 
    - `LoginModel`: contains two string members for username and password.
    - `RegisterModel`: contains two string members for username and password.
      
- **Service classes**:
    - `LocalBlobStorageProvider`: responsible for storing and retrieving files.
    - `MetadataRepository`: responsible for storing and retrieving file's meta-data.
    - `UserService`: responsible for user authentication and registeration.
    - `FileService`: responsible for storing and retrieving files, internally should use LocalBlobStorageProvider and MetadataRepository.
      
#### Database schema
we will use Asp.net membership SQL tables, it can be generated by Entity-framework migration commands
- **"Files" table fields**:
  - `FileId`: nvarchar(450), contains new random GUID.
  - `FileName`: nvarchar(MAX), contains file name.
  - `ContentType`: nvarchar(MAX).
  - `Size`: bigint.
  - `FilePath`: nvarchar(MAX), path on local storage.
  - `UserId`: nvarchar(450), foriegn key to users table.


## 3. Storage Type and File Handling

### Storage Type
- **Local Storage**: Files will be stored on service local storage medium.
  - **Reason**: Preferred for data residency and lower latency.

### File Handling
- **Saving Files**:
  - Files are uploaded to the storage service.
  - The service generates a unique GUID and stores the file in the storage backend.
  - Metadata is stored in a metadata database.
- **Retrieving Files**:
  - The storage service retrieves the file using the unique GUID from the storage backend.
  - Metadata is retrieved from the metadata database.
- **Security**:
  - Files are encrypted at rest and in transit.
  - Access is controlled via the authentication and authorization end-points.

## 4. Communication with Other Microservices

### API Communication
- Other microservices communicate with the storage microservice via the API Gateway.
- **RESTful Endpoints**:
  - Use standard HTTP methods (GET, POST, PUT, DELETE) for interaction.
  - Endpoints are secured using tokens or API keys.

### Example Workflow

1. **Authentication**: A microservice sends a `POST` request to `/api/users/authenticate` with authorized credentials, a JWT token will be returned in response when authentication succeedes.

   example of authentication HTTP JSON response:
  {"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1bmlxdWVfbmFtZSI6ImQ1NjU0NDUzLTNmODYtNDE3Ni04Mzg0LTNmMTVmNDk2MWIwOSIsIm5iZiI6MTcyMTYxMDQwNywiZXhwIjoxNzIxNjE0MDA3LCJpYXQiOjE3MjE2MTA0MDd9.0baizSDCgg6qetHaDBmIRktgobwuX-RhUPLPYdWJX8I"}

   example of HTTP subsequent HTTP requests authorization header:
   Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ
   
3. **Upload**: A microservice sends a `POST` request to `/api/file/upload` with the file raw data, session JWT token should be in request HTTP header.
4. **Get Files List**: A microservice sends a `GET` request to `/api/file/myfiles` session JWT token should be in request HTTP header.

   example of HTTP JSON response:
   {
     "FileId": "01F7CA98-2A5B-4C27-B65E-A82B20DAD722",
     "FileName": "research-article.pdf",
     "ContentType": "application/pdf",
   }

   the field "FileId" will be used in "delete", "replace" and "download" requests
5. **Download**: A microservice sends a `GET` request to `/api/file/download/{fileid}` with the file ID in URL, session JWT token should be in request HTTP header. the response is raw file.
6. **Delete**: A microservice sends a `DELETE` request to `/api/file/delete/{fileid}` with the file ID in URL, session JWT token should be in request HTTP header.
7. **Replace**: A microservice sends a `PUT` request to `/api/file/replace/{fileid}`  with the file ID in URL, session JWT token should be in request HTTP header. like "upload" the new file raw data should be in request.

### example C# code for uploading
```csharp
using System;
using System.IO;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text;
using System.Threading.Tasks;
using Newtonsoft.Json;

public class Program
{
    private static readonly HttpClient client = new HttpClient();

    public static async Task Main(string[] args)
    {
        string authUrl = "https://file-storage-service-base-URL/api/users/authenticate";
        string uploadUrl = "https://file-storage-service-base-URL/api/file/upload";
        string username = "user1";
        string password = "1234";
        string filePath = "c:\myfiles\myfile.txt";

        try
        {
            // Authenticate and get JWT token
            string token = await AuthenticateAsync(authUrl, username, password);
            Console.WriteLine("Token received: " + token);

            // Upload file using the token
            await UploadFileAsync(uploadUrl, filePath, token);
        }
        catch (Exception ex)
        {
            Console.WriteLine("Error: " + ex.Message);
        }
    }

    private static async Task<string> AuthenticateAsync(string authUrl, string username, string password)
    {
        var credentials = new
        {
            username = username,
            password = password
        };

        var content = new StringContent(JsonConvert.SerializeObject(credentials), Encoding.UTF8, "application/json");

        HttpResponseMessage response = await client.PostAsync(authUrl, content);
        response.EnsureSuccessStatusCode();

        var responseString = await response.Content.ReadAsStringAsync();
        dynamic responseJson = JsonConvert.DeserializeObject(responseString);

        return responseJson.token;
    }

    private static async Task UploadFileAsync(string uploadUrl, string filePath, string token)
    {
        using (var fileStream = new FileStream(filePath, FileMode.Open, FileAccess.Read))
        using (var content = new MultipartFormDataContent())
        using (var fileContent = new StreamContent(fileStream))
        {
            fileContent.Headers.ContentType = MediaTypeHeaderValue.Parse("multipart/form-data");
            content.Add(fileContent, "file", Path.GetFileName(filePath));

            client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", token);

            HttpResponseMessage response = await client.PostAsync(uploadUrl, content);
            response.EnsureSuccessStatusCode();

            Console.WriteLine("File uploaded successfully!");
        }
    }
}
```
## 5. Files in this GitHub Repository

### FileStorage.sln
Microsoft visual studio 2022 sample solution for REST API, you will need to update the appsettings.json with Microsoft SQL server DB connection string.

### FileStorageDB.bacpac
Microsoft SQL server sample DB data tier application.

### NOTES:
- file encryption function not implemented yet due to time constraints

## 6. Further potential enhancements
- add third-party authentication providers like google, facebook and microsoft accounts, if organization's security policy allows.
- add support for cloud file storage, if organization's security policy allows.


